//! Code for parallel-building a set of targets.

use failure::{format_err, Backtrace, Context, Error, Fail, ResultExt};
use futures::future::FusedFuture;
use futures::stream::{FusedStream, FuturesUnordered, Stream};
use futures::{pin_mut, select};
use nix::sys::signal::{self, SigHandler, Signal};
use nix::unistd;
use rand;
use rusqlite::{DropBehavior, TransactionBehavior};
use std::cell::Cell;
use std::cell::RefCell;
use std::cmp;
use std::collections::HashSet;
use std::collections::VecDeque;
use std::convert::TryInto;
use std::env;
use std::ffi::{CString, OsStr, OsString};
use std::fmt::{self, Display};
use std::fs::Metadata;
use std::fs::{self, File};
use std::future::{self, Future};
use std::io::{self, BufRead, BufReader};
use std::mem;
use std::os::unix::io::RawFd;
use std::path::{Path, PathBuf};
use std::pin::Pin;
use std::rc::Rc;
use std::time::Duration;
use tempfile;

use super::env::Env;
use super::helpers::{self, OsBytes};
use super::jobserver::JobServerHandle;
use super::paths;
use super::state::{self, Lock, LockType, ProcessState, ProcessTransaction, Stamp};

pub fn close_stdin() -> Result<(), Error> {
    use std::os::unix::io::AsRawFd;
    let f = File::open("/dev/null")?;
    unistd::dup2(f.as_raw_fd(), io::stdin().as_raw_fd())?;
    Ok(())
}

/// Await the redo-log instance we redirected stderr to, if any.
pub fn await_log_reader(env: &Env, stderr_fd: RawFd) -> Result<(), Error> {
    use std::os::unix::io::AsRawFd;
    if env.log == 0 {
        return Ok(());
    }
    if false {
        // TODO(now): Check for log reader PID and wait on it.

        // never actually close fd#1 or fd#2; insanity awaits.
        // replace it with something else instead.
        // Since our stdout/stderr are attached to redo-log's stdin,
        // this will notify redo-log that it's time to die (after it finishes
        // reading the logs)
        unistd::dup2(stderr_fd, io::stdout().as_raw_fd())?;
        unistd::dup2(stderr_fd, io::stderr().as_raw_fd())?;
    }
    Ok(())
}

struct BuildJob {
    /// Original target name. (Not relative to `Env.base`).
    t: String,
    sf: state::File,
    lock: Lock,
    should_build_func: Option<Box<dyn FnOnce(&str) -> Result<(bool, bool), Error>>>,
}

impl BuildJob {
    const INTERNAL_ERROR_EXIT: i32 = 209;

    /// Actually start running this job in a subproc, if needed.
    ///
    /// `ps_ref` must be the same state as in `ptx`. `ps_ref` is mutably borrowed
    /// during the future's execution.
    fn start<'a>(
        mut self,
        ps_ref: Rc<RefCell<&'a mut ProcessState>>,
        ptx: ProcessTransaction<'_>,
        server: &JobServerHandle,
    ) -> Result<Pin<Box<dyn Future<Output = i32> + 'a>>, Error> {
        let before_t = try_stat(&self.t)?;
        debug_assert!(self.lock.is_owned());
        let (is_target, dirty) = (self
            .should_build_func
            .take()
            .unwrap_or(Box::new(|_| Ok((true, true)))))(&self.t)?;
        if !dirty {
            // Target doesn't need to be built; skip the whole task.
            // TODO(soon): If is_target, meta unchanged.
            return Ok(Box::pin(future::ready(0)));
        }
        if ptx.state().env().no_oob || dirty {
            self.start_self(ps_ref, ptx, server, before_t)
        } else {
            //self.start_deps_unlocked(dirty)
            unimplemented!()
        }
    }

    /// Run `JobServer::start` to build this object's target file.
    fn start_self<'a>(
        self,
        ps_ref: Rc<RefCell<&'a mut ProcessState>>,
        mut ptx: ProcessTransaction<'_>,
        server: &JobServerHandle,
        before_t: Option<Metadata>,
    ) -> Result<Pin<Box<dyn Future<Output = i32> + 'a>>, Error> {
        use std::os::unix::io::AsRawFd;

        debug_assert!(self.lock.is_owned());
        let t = self.t;
        let mut sf = self.sf;

        let newstamp = sf.read_stamp(ptx.state().env())?;
        if sf.is_generated
            && !newstamp.is_missing()
            && (sf.is_override || Stamp::detect_override(sf.stamp.as_ref().unwrap(), &newstamp))
        {
            sf.save(&mut ptx)?;
            // Fall through and treat it the same as a static file.
        }
        if Path::new(&t).exists()
            && !Path::new(&t).join(".").is_dir()
            && (sf.is_override || !sf.is_generated)
        {
            // an existing source file that was not generated by us.
            // This step is mentioned by djb in his notes.
            // For example, a rule called default.c.do could be used to try
            // to produce hello.c, but we don't want that to happen if
            // hello.c was created by the end user.
            if !sf.is_override {
                sf.set_static(ptx.state().env())?;
            }
            sf.save(&mut ptx)?;
            return Ok(Box::pin(future::ready(0)));
        }
        sf.zap_deps1(&mut ptx)?;
        let df = match paths::find_do_file(&mut ptx, &mut sf)? {
            Some(df) => df,
            None => {
                let rv = if Path::new(&t).exists() {
                    sf.set_static(ptx.state().env())?;
                    0
                } else {
                    sf.set_failed(ptx.state().env())?;
                    1
                };
                sf.save(&mut ptx)?;
                return Ok(Box::pin(future::ready(rv)));
            }
        };
        // There is no good place for us to pre-create a temp file for
        // stdout.  The target dir might not exist yet, or it might currently
        // exist but get wiped by the .do script.  Other dirs, like the one
        // containing the .do file, might be mounted readonly.  We can put it
        // in the system temp dir, but then we can't necessarily rename it to
        // the target filename because it might cross filesystem boundaries.
        // Also, if redo is interrupted, it would leave a temp file lying
        // around.  To avoid all this, use mkstemp() to create a temp file
        // wherever it wants to, and immediately unlink it, but keep a file
        // handle open.  When the .do script finishes, we can copy the
        // content out of that nameless file handle into a file in the same
        // dir as the target (which by definition must now exist, if you
        // wanted the target to exist).
        //
        // On the other hand, the $3 temp filename can be hardcoded to be in
        // the target directory, even if that directory does not exist.
        // It's not *redo*'s job to create that file.  The .do file will
        // create it, if it wants, and it's the .do file's job to first ensure
        // that the directory exists.
        let tmp_name = {
            let mut tmp_base_name = OsString::new();
            tmp_base_name.push(&df.base_name);
            tmp_base_name.push(&df.ext);
            tmp_base_name.push(".redo.tmp");
            df.do_dir.join(tmp_base_name)
        };
        helpers::unlink(&tmp_name)?;
        let out_file = tempfile::tempfile()?;
        helpers::close_on_exec(out_file.as_raw_fd(), true)?;
        // this will run in the dofile's directory, so use only basenames here
        let arg1 = {
            // target name (with extension)
            let mut arg1 = OsString::new();
            arg1.push(&df.base_name);
            arg1.push(&df.ext);
            arg1
        };
        let arg2 = {
            // target name (without extension)
            let mut arg2 = OsString::new();
            arg2.push(&df.base_name);
            arg2
        };
        let cwd = env::current_dir()?;
        let mut argv: Vec<OsString> = vec![
            OsString::from("sh"),
            OsString::from("-e"),
            df.do_file.clone(),
            arg1,
            arg2,
            // $3 temp output file name
            state::relpath(helpers::abs_path(&cwd, &tmp_name), &df.do_dir)?.into_os_string(),
        ];
        if ptx.state().env().verbose != 0 {
            argv[1].push("v");
        }
        if ptx.state().env().xtrace != 0 {
            argv[1].push("x");
        }
        let firstline = {
            let f = File::open(df.do_dir.join(&df.do_file))?;
            let mut f = BufReader::new(f);
            let mut firstline = String::new();
            f.read_line(&mut firstline)?;
            firstline
        };
        let firstline = firstline.trim();
        if firstline.starts_with("#!/") {
            let interpreter: Vec<&str> = firstline[2..].split(' ').collect();
            let mut new_argv: Vec<OsString> =
                Vec::with_capacity(argv.len() - 2 + interpreter.len());
            new_argv.extend(interpreter.into_iter().map(|s| OsString::from(s)));
            new_argv.extend(argv.into_iter().skip(2));
            argv = new_argv;
        }
        // make sure to create the logfile *before* writing the meta() about
        // it.  that way redo-log won't trace into an obsolete logfile.
        //
        // We open a temp file and atomically rename it into place here.
        // This guarantees that redo-log will never experience a file that
        // gets truncated halfway through reading (eg.  if we build the same
        // target more than once in a run).  Similarly, we don't want to
        // actually unlink() the file in case redo-log is about to start
        // reading a previous instance created during this session.  It
        // should always see either the old or new instance.
        let ps = ptx.commit()?;

        // Wrap out_file in a Cell, since we drop it in the subprocess.
        // Rust can't tell that the closure is not called in the parent process.
        let out_file = Cell::new(Some(out_file));

        let job = server.start(|| {
            // TODO(someday): Log errors.
            use std::iter::FromIterator;

            // careful: REDO_PWD was the PWD relative to the STARTPATH at the time
            // we *started* building the current target; but that target ran
            // redo-ifchange, and it might have done it from a different directory
            // than we started it in.  So os.getcwd() might be != REDO_PWD right
            // now.
            assert!(ps.is_flushed());
            let newp = match df.do_dir.canonicalize() {
                Ok(newp) => newp,
                Err(_) => return 1,
            };
            env::remove_var("CDPATH");
            env::set_var(
                "REDO_PWD",
                match state::relpath(newp, &ps.env().startdir) {
                    Ok(path) => path,
                    Err(_) => return 1,
                },
            );
            env::set_var("REDO_TARGET", {
                let mut target = OsString::new();
                target.push(&df.base_name);
                target.push(&df.ext);
                target
            });
            env::set_var("REDO_DEPTH", {
                let mut depth = OsString::new();
                depth.push(&ps.env().depth);
                depth.push("  ");
                depth
            });
            if ps.env().xtrace == 1 {
                env::set_var("REDO_TARGET", "0");
            }
            if ps.env().verbose == 1 {
                env::set_var("REDO_VERBOSE", "0");
            }
            // TODO(soon): cycles.add(self.lock.fid)
            if !df.do_dir.as_os_str().is_empty() {
                if env::set_current_dir(&df.do_dir).is_err() {
                    return 1;
                }
            }
            let out_file = out_file.take().unwrap();
            if unistd::dup2(out_file.as_raw_fd(), 1).is_err() {
                return 1;
            }
            mem::drop(out_file);
            if helpers::close_on_exec(1, false).is_err() {
                return 1;
            }
            // TODO(someday): if env.v.LOG
            {
                // else:
                env::remove_var("REDO_LOG_INODE");
                env::set_var("REDO_LOG", "");
            }
            if unsafe { signal::signal(Signal::SIGPIPE, SigHandler::SigDfl) }.is_err() {
                return 1;
            }
            if ps.env().verbose != 0 || ps.env().xtrace != 0 {
                // TODO(someday): logs.write
            }
            let argv = Vec::from_iter(
                argv.iter()
                    .map(|s| CString::new(Vec::from_iter(OsBytes::new(s))).unwrap()),
            );
            let _ = unistd::execvp(argv[0].as_c_str(), argv.as_slice());
            // Returns only if execvp failed.
            1
        })?;
        let out_file = out_file.take().unwrap();
        Ok(Box::pin(async move {
            let mut rv = job.await;
            let mut ps = ps_ref.borrow_mut();
            let mut ptx = match ProcessTransaction::new(*ps, TransactionBehavior::Deferred) {
                Ok(ptx) => ptx,
                Err(_) => return BuildJob::INTERNAL_ERROR_EXIT,
            };
            rv = BuildJob::record_new_state(
                &mut ptx, &t, sf, &before_t, out_file, &tmp_name, &argv, rv,
            );
            if let Err(e) = ptx.commit() {
                eprintln!("{:?}: {}", &t, e);
                return BuildJob::INTERNAL_ERROR_EXIT;
            }
            rv
        }))
    }

    /// After a subtask finishes, handle its changes to the output file.
    //
    /// This is run in the *parent* process.
    //
    /// This includes renaming temp files into place and detecting mistakes
    /// (like writing directly to $1 instead of $3).  We also have to record
    /// the new file stamp data for the completed target.
    fn record_new_state<A: AsRef<OsStr>>(
        ptx: &mut ProcessTransaction<'_>,
        t: &str,
        mut sf: state::File,
        before_t: &Option<Metadata>,
        mut out_file: File,
        tmp_name: &Path,
        argv: &[A],
        mut rv: i32,
    ) -> i32 {
        use std::io::{Seek, SeekFrom};
        use std::os::unix::fs::MetadataExt;

        let after_t = try_stat(t).expect("cannot get target metadata");
        let st1 = out_file.metadata().expect("cannot get out_file metadata");
        let mut st2 = try_stat(tmp_name).expect("unexpected error when statting $3");
        // TODO(now)
        let modified = match after_t {
            Some(after_t) => {
                after_t.is_dir()
                    && match before_t {
                        Some(before_t) => match (before_t.modified(), after_t.modified()) {
                            (Ok(before_mod), Ok(after_mod)) => before_mod != after_mod,
                            _ => false,
                        },
                        None => true,
                    }
            }
            None => false,
        };
        if modified {
            eprintln!("{:?} modified {} directly!", argv[2].as_ref(), t);
            eprintln!("... you should update $3 (a temp file) or stdout, not $1.");
            rv = 206;
        } else if st2.is_some() && st1.size() > 0 {
            eprintln!("{:?} wrote to stdout *and* created $3.", argv[2].as_ref());
            eprintln!("... you should write status messages to stderr, not stdout.");
            rv = 207;
        }
        if rv == 0 {
            // FIXME: race condition here between updating stamp/is_generated
            // and actually renaming the files into place.  There needs to
            // be some kind of two-stage commit, I guess.
            if st1.size() > 0 && st2.is_none() {
                // script wrote to stdout.  Copy its contents to the tmpfile.
                helpers::unlink(tmp_name)
                    .expect("failed to remove old temp file before copying stdout");
                match File::create(tmp_name) {
                    Err(e) => {
                        let cwd = &env::current_dir().expect("cannot get working directory");
                        let abs_t = helpers::abs_path(cwd, t);
                        let dnt = abs_t.parent();
                        if dnt.map_or(false, |dnt| dnt.exists()) {
                            // This could happen, so report a simple error message
                            // that gives a hint for how to fix your .do script.
                            eprintln!(
                                "{:?}: target dir {:?} does not exist!",
                                t,
                                dnt.unwrap_or(Path::new(""))
                            );
                        } else {
                            // This could happen for, eg. a permissions error on
                            // the target directory.
                            eprintln!("{:?}: copy stdout: {}", t, e);
                        }
                        rv = BuildJob::INTERNAL_ERROR_EXIT;
                    }
                    Ok(mut newf) => {
                        out_file
                            .seek(SeekFrom::Start(0))
                            .expect("could not seek to beginning of stdout");
                        io::copy(&mut out_file, &mut newf).expect("could not copy stdout");
                        st2 = Some(
                            newf.metadata()
                                .expect("cannot get copied stdout file metadata"),
                        );
                    }
                }
            }
            if st2.is_some() {
                // either $3 file was created *or* stdout was written to.
                // therefore tmpfile now exists.
                if let Err(e) = fs::rename(tmp_name, t) {
                    // This could happen for, eg. a permissions error on
                    // the target directory.
                    eprintln!("{:?}: rename {:?}: {}", t, tmp_name, e);
                    rv = BuildJob::INTERNAL_ERROR_EXIT;
                }
            } else {
                // no output generated at all; that's ok
                helpers::unlink(t).expect("failed to remove target file");
            }
            if let Err(e) = sf.refresh(ptx) {
                eprintln!("{:?}: refresh: {}", t, e);
                rv = BuildJob::INTERNAL_ERROR_EXIT;
            }
            sf.is_generated = true;
            sf.is_override = false;
            if sf.is_checked(ptx.state().env()) || sf.is_changed(ptx.state().env()) {
                // it got checked during the run; someone ran redo-stamp.
                // update_stamp would call set_changed(); we don't want that,
                // so only use read_stamp.
                sf.stamp = Some(
                    sf.read_stamp(ptx.state().env())
                        .expect("target file stat failed"),
                );
            } else {
                sf.csum = None;
                if let Err(e) = sf.update_stamp(ptx.state().env(), false) {
                    eprintln!("{:?}: update stamp: {}", t, e);
                    rv = BuildJob::INTERNAL_ERROR_EXIT;
                }
                sf.set_changed(ptx.state().env());
            }
        }
        // rv might have changed up above
        if rv != 0 {
            helpers::unlink(tmp_name).expect("failed to remove temporary output file");
            if let Err(e) = sf.set_failed(ptx.state().env()) {
                eprintln!("{:?}: set failed: {}", t, e);
                rv = BuildJob::INTERNAL_ERROR_EXIT;
            }
        }
        if let Err(e) = sf.zap_deps2(ptx) {
            eprintln!("{:?}: zap_deps2: {}", t, e);
            rv = BuildJob::INTERNAL_ERROR_EXIT;
        }
        if let Err(e) = sf.save(ptx) {
            eprintln!("{:?}: set failed: {}", t, e);
            rv = BuildJob::INTERNAL_ERROR_EXIT;
        }
        rv
    }
}

pub async fn run<S: AsRef<str>>(
    ps: &mut ProcessState,
    server: &JobServerHandle,
    targets: &[S],
) -> Result<(), BuildError> {
    use futures::future::FutureExt;
    use futures::stream::StreamExt;
    use std::convert::TryFrom;

    for t in targets {
        let t = t.as_ref();
        if t.find('\n').is_some() {
            return Err(BuildErrorKind::InvalidTarget(t.into()).into());
        }
    }

    let mut me: Option<(PathBuf, state::File, Lock)> =
        if !ps.env().target.as_os_str().is_empty() && !ps.env().unlocked {
            let mut me = PathBuf::from(&ps.env().startdir);
            me.push(&ps.env().pwd);
            me.push(&ps.env().target);
            let myfile = {
                let mut ptx = ProcessTransaction::new(ps, TransactionBehavior::Deferred)
                    .context(BuildErrorKind::Generic)?;
                ptx.set_drop_behavior(DropBehavior::Commit);
                state::File::from_name(&mut ptx, &me.to_string_lossy(), true)
                    .context(BuildErrorKind::Generic)?
            };
            let selflock = ps.new_lock(state::LOG_LOCK_MAGIC + (myfile.id as i32));
            Some((me, myfile, selflock))
        } else {
            None
        };

    let result: Cell<Result<(), BuildError>> = Cell::new(Ok(()));
    let mut locked: VecDeque<(i64, &str)> = VecDeque::new();
    let mut cheat = || -> Result<i32, Error> {
        let selflock = match &mut me {
            Some((_, _, ref mut selflock)) => selflock,
            None => return Ok(0),
        };
        selflock.try_lock()?;
        if !selflock.is_owned() {
            // redo-log already owns it: let's cheat.
            // Give ourselves one extra token so that the "foreground" log
            // can always make progress.
            Ok(1)
        } else {
            // redo-log isn't watching us (yet)
            selflock.unlock()?;
            Ok(0)
        }
    };
    // In the first cycle, we just build as much as we can without worrying
    // about any lock contention.  If someone else has it locked, we move on.
    let ps_ref = Rc::new(RefCell::new(ps));
    let job_futures: FuturesUnordered<Pin<Box<dyn Future<Output = ()>>>> = FuturesUnordered::new();
    pin_mut!(job_futures);
    {
        let mut seen: HashSet<String> = HashSet::new();
        for t in targets {
            let t = t.as_ref();
            if t.is_empty() {
                result.set(Err(BuildErrorKind::InvalidTarget(t.into()).into()));
                break;
            }
            assert!(ps_ref.borrow().is_flushed());
            if seen.contains(t) {
                continue;
            }
            seen.insert(t.into());
            // TODO(maybe): Commit state if !has_token.
            let token_future = server.ensure_token_or_cheat(t, &mut cheat).fuse();
            pin_mut!(token_future);
            wait_for(token_future, job_futures.as_mut())
                .await
                .context(BuildErrorKind::Generic)?;
            let errored = {
                let r = result.replace(Ok(()));
                let errored = r.is_err();
                result.set(r);
                errored
            };
            if errored && !ps_ref.borrow().env().keep_going {
                break;
            }
            // TODO(soon): state.check_sane.
            {
                let mut ps = ps_ref.borrow_mut();
                let mut ptx = ProcessTransaction::new(*ps, TransactionBehavior::Deferred)
                    .context(BuildErrorKind::Generic)?;
                ptx.set_drop_behavior(DropBehavior::Commit);
                let mut f =
                    state::File::from_name(&mut ptx, t, true).context(BuildErrorKind::Generic)?;
                let mut lock = ptx.state().new_lock(f.id.try_into().unwrap());
                if ptx.state().env().unlocked {
                    lock.force_owned();
                } else {
                    lock.try_lock().context(BuildErrorKind::Generic)?;
                }
                if !lock.is_owned() {
                    // TODO(soon): meta something?
                    locked.push_back((f.id, t));
                } else {
                    // We had to create f before we had a lock, because we need f.id
                    // to make the lock.  But someone may have updated the state
                    // between then and now.
                    // FIXME: separate obtaining the fid from creating the File.
                    // FIXME: maybe integrate locking into the File object?
                    f.refresh(&mut ptx).context(BuildErrorKind::Generic)?;
                    let job = BuildJob {
                        t: t.into(),
                        sf: f,
                        lock,
                        should_build_func: None,
                    }
                    .start(ps_ref.clone(), ptx, server)
                    .context(BuildErrorKind::Generic)?;
                    let t = t.to_string();
                    let result = &result;
                    job_futures.push(Box::pin(async move {
                        let rv = job.await;
                        if rv != 0 {
                            result.set(Err(format_err!("{:?}: exit code {}", t, rv)
                                .context(BuildErrorKind::Generic)
                                .into()));
                        }
                    }));
                }
            }
            assert!(ps_ref.borrow().is_flushed());
        }
    }

    // Now we've built all the "easy" ones.  Go back and just wait on the
    // remaining ones one by one.  There's no reason to do it any more
    // efficiently, because if these targets were previously locked, that
    // means someone else was building them; thus, we probably won't need to
    // do anything.  The only exception is if we're invoked as redo instead
    // of redo-ifchange; then we have to redo it even if someone else already
    // did.  But that should be rare.
    while !locked.is_empty() || server.is_running() {
        let jobs_done_future = server.wait_all();
        pin_mut!(jobs_done_future);
        wait_for(jobs_done_future, job_futures.as_mut())
            .await
            .context(BuildErrorKind::Generic)?;
        let errored = {
            let r = result.replace(Ok(()));
            let errored = r.is_err();
            result.set(r);
            errored
        };
        if errored && !ps_ref.borrow().env().keep_going {
            break;
        }
        if let Some((fid, t)) = locked.pop_front() {
            // TODO(soon): check_sane
            let mut lock = ps_ref
                .borrow()
                .new_lock(i32::try_from(fid).context(BuildErrorKind::Generic)?);
            let mut backoff = Duration::from_millis(100);
            lock.try_lock().context(BuildErrorKind::Generic)?;
            while !lock.is_owned() {
                // Don't spin with 100% CPU while we fight for the lock.
                server
                    .sleep(Duration::from_millis(
                        (rand::random::<f32>()
                            * (cmp::min(backoff, Duration::from_millis(1000)).as_millis()) as f32)
                            as u64,
                    ))
                    .await;
                backoff *= 2;
                // after printing this line, redo-log will recurse into t,
                // whether it's us building it, or someone else.
                // TODO(someday): Check for cyclic dependency error.
                lock.check();
                // this sequence looks a little silly, but the idea is to
                // give up our personal token while we wait for the lock to
                // be released; but we should never run ensure_token() while
                // holding a lock, or we could cause deadlocks.
                server.release_mine().context(BuildErrorKind::Generic)?;
                lock.wait_lock(LockType::Exclusive)
                    .context(BuildErrorKind::Generic)?;
                // now t is definitely free, so we get to decide whether
                // to build it.
                lock.unlock().context(BuildErrorKind::Generic)?;
                server
                    .ensure_token_or_cheat(t, &mut cheat)
                    .await
                    .context(BuildErrorKind::Generic)?;
                lock.try_lock().context(BuildErrorKind::Generic)?;
            }
            {
                let mut ps = ps_ref.borrow_mut();
                let mut ptx = ProcessTransaction::new(*ps, TransactionBehavior::Deferred)
                    .context(BuildErrorKind::Generic)?;
                ptx.set_drop_behavior(DropBehavior::Commit);
                let file =
                    state::File::from_name(&mut ptx, t, true).context(BuildErrorKind::Generic)?;
                if file.is_failed(ptx.state().env()) {
                    result.set(Err(
                        BuildErrorKind::FailedInAnotherThread(t.to_string()).into()
                    ));
                    lock.unlock().context(BuildErrorKind::Generic)?;
                } else {
                    let sf =
                        state::File::from_id(&mut ptx, fid).context(BuildErrorKind::Generic)?;
                    let job = BuildJob {
                        t: t.to_string(),
                        sf,
                        lock,
                        should_build_func: None,
                    }
                    .start(ps_ref.clone(), ptx, server)
                    .context(BuildErrorKind::Generic)?;
                    job_futures.push(Box::pin(async {
                        let rv = job.await;
                        if rv != 0 {
                            result.set(Err(BuildErrorKind::Generic.into()));
                        }
                    }));
                }
            }
        }
    }
    // TODO(maybe): Use !job_futures.is_empty() instead of server.is_running() in
    // the above loop.
    job_futures.fold((), |_, _| future::ready(())).await;
    result.replace(Ok(()))
}

/// Polls a future and a stream, discarding any results from the stream.
async fn wait_for<T, F, S>(mut fg_future: Pin<&mut F>, mut bg_stream: Pin<&mut S>) -> T
where
    F: Future<Output = T> + FusedFuture,
    S: Stream + FusedStream,
{
    use futures::stream::StreamExt;

    let mut next_bg = bg_stream.next();
    loop {
        select! {
            x = fg_future => return x,
            _ = next_bg => {
                next_bg = bg_stream.next();
            }
        }
    }
}

fn try_stat<P: AsRef<Path>>(path: P) -> io::Result<Option<Metadata>> {
    match path.as_ref().metadata() {
        Ok(m) => Ok(Some(m)),
        Err(e) => match e.kind() {
            io::ErrorKind::NotFound => Ok(None),
            _ => Err(e),
        },
    }
}

#[derive(Debug)]
pub struct BuildError {
    inner: Context<BuildErrorKind>,
}

#[derive(Clone, Eq, PartialEq, Debug, Fail)]
#[non_exhaustive]
pub enum BuildErrorKind {
    #[fail(display = "Build failed")]
    Generic,
    #[fail(display = "{:?}: failed in another thread", _0)]
    FailedInAnotherThread(String),
    #[fail(display = "Invalid target {:?}", _0)]
    InvalidTarget(String),
}

impl BuildError {
    #[inline]
    pub fn kind(&self) -> &BuildErrorKind {
        self.inner.get_context()
    }
}

impl Fail for BuildError {
    fn cause(&self) -> Option<&dyn Fail> {
        self.inner.cause()
    }

    fn backtrace(&self) -> Option<&Backtrace> {
        self.inner.backtrace()
    }
}

impl Display for BuildError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Display::fmt(&self.inner, f)
    }
}

impl From<BuildErrorKind> for BuildError {
    fn from(kind: BuildErrorKind) -> BuildError {
        BuildError {
            inner: Context::new(kind),
        }
    }
}

impl From<Context<BuildErrorKind>> for BuildError {
    fn from(inner: Context<BuildErrorKind>) -> BuildError {
        BuildError { inner: inner }
    }
}

impl Default for BuildErrorKind {
    #[inline]
    fn default() -> BuildErrorKind {
        BuildErrorKind::Generic
    }
}

impl From<&BuildErrorKind> for i32 {
    fn from(kind: &BuildErrorKind) -> i32 {
        match kind {
            BuildErrorKind::FailedInAnotherThread(_) => 2,
            BuildErrorKind::InvalidTarget(_) => 204,
            _ => 1,
        }
    }
}
