use failure::{Backtrace, Context, Error, Fail, ResultExt};
use nix::unistd;
use rusqlite::{DropBehavior, TransactionBehavior};
use std::collections::HashSet;
use std::convert::TryInto;
use std::fmt::{self, Display};
use std::fs::File;
use std::future::{self, Future};
use std::io;
use std::os::unix::io::RawFd;
use std::path::{self, Path, PathBuf};

use super::env::Env;
use super::jobserver::JobStarter;
use super::paths::{self, DoFile};
use super::state::{self, Lock, ProcessState, ProcessTransaction, Stamp};

pub(crate) fn close_stdin() -> Result<(), Error> {
    use std::os::unix::io::AsRawFd;
    let f = File::open("/dev/null")?;
    unistd::dup2(f.as_raw_fd(), io::stdin().as_raw_fd())?;
    Ok(())
}

pub(crate) fn await_log_reader(env: &Env, stderr_fd: RawFd) -> Result<(), Error> {
    use std::os::unix::io::AsRawFd;
    if env.log == 0 {
        return Ok(());
    }
    if false {
        // TODO(now): Check for log reader PID and wait on it.

        // never actually close fd#1 or fd#2; insanity awaits.
        // replace it with something else instead.
        // Since our stdout/stderr are attached to redo-log's stdin,
        // this will notify redo-log that it's time to die (after it finishes
        // reading the logs)
        unistd::dup2(stderr_fd, io::stdout().as_raw_fd())?;
        unistd::dup2(stderr_fd, io::stderr().as_raw_fd())?;
    }
    Ok(())
}

struct BuildJob {
    /// Original target name. (Not relative to `Env.base`).
    t: String,
    sf: state::File,
    tmp_name: Option<String>,
    lock: Lock,
    should_build_func: Option<Box<dyn FnOnce(&str) -> Result<(bool, bool), Error>>>,
    done_func: Box<dyn FnOnce(String, i32)>,
}

impl BuildJob {
    /// Actually start running this job in a subproc, if needed.
    async fn start(mut self, ps: &mut ProcessState, server: &mut JobStarter) -> Result<(), Error> {
        debug_assert!(self.lock.is_owned());
        let (is_target, dirty) = (self.should_build_func.take().unwrap())(&self.t)?;
        if !dirty {
            // Target doesn't need to be built; skip the whole task.
            // TODO(soon): If is_target, meta unchanged.
            return BuildJob::finalize(self.lock, self.done_func, self.t, 0);
        }
        if ps.env().no_oob || dirty {
            self.start_self(ps, server).await
        } else {
            //self.start_deps_unlocked(dirty)
            unimplemented!()
        }
    }

    /// Run `JobServer::start` to build this object's target file.
    async fn start_self(
        mut self,
        ps: &mut ProcessState,
        server: &mut JobStarter,
    ) -> Result<(), Error> {
        debug_assert!(self.lock.is_owned());
        let t = self.t;
        let mut sf = self.sf;

        {
            let mut ptx = ProcessTransaction::new(ps, TransactionBehavior::Deferred)?;
            ptx.set_drop_behavior(DropBehavior::Commit);
            let newstamp = sf.read_stamp(ptx.state().env())?;
            if sf.is_generated
                && !newstamp.is_missing()
                && (sf.is_override || Stamp::detect_override(sf.stamp.as_ref().unwrap(), &newstamp))
            {
                sf.save(&mut ptx)?;
                // Fall through and treat it the same as a static file.
            }
            if Path::new(&t).exists()
                && !Path::new(&t).join(".").is_dir()
                && (sf.is_override || !sf.is_generated)
            {
                // an existing source file that was not generated by us.
                // This step is mentioned by djb in his notes.
                // For example, a rule called default.c.do could be used to try
                // to produce hello.c, but we don't want that to happen if
                // hello.c was created by the end user.
                if !sf.is_override {
                    sf.set_static(ptx.state().env())?;
                }
                sf.save(&mut ptx)?;
                return BuildJob::finalize(self.lock, self.done_func, t, 0);
            }
            sf.zap_deps1(&mut ptx)?;
            match paths::find_do_file(&mut ptx, &mut sf)? {
                Some(df) => df,
                None => {
                    let rv = if Path::new(&t).exists() {
                        sf.set_static(ptx.state().env())?;
                        0
                    } else {
                        sf.set_failed(ptx.state().env())?;
                        1
                    };
                    sf.save(&mut ptx)?;
                    return BuildJob::finalize(self.lock, self.done_func, t, rv);
                }
            };
            // TODO(now): Create stdout temp file and so on.
            server.start(|| 0)?.await;
            Ok(())
        }
    }

    /// After a target is built, report completion and unlock. This is run in
    /// the *parent* process.
    ///
    /// Note: you usually need to call `record_new_state()` first.
    fn finalize(
        mut lock: Lock,
        done_func: Box<dyn FnOnce(String, i32)>,
        t: String,
        rv: i32,
    ) -> Result<(), Error> {
        done_func(t, rv);
        debug_assert!(lock.is_owned());
        lock.unlock()?;
        Ok(())
    }
}

pub(crate) async fn run<S: AsRef<str>>(
    ps: &mut ProcessState,
    server: &mut JobStarter,
    targets: &[S],
) -> Result<(), BuildError> {
    for t in targets {
        let t = t.as_ref();
        if t.find('\n').is_some() {
            return Err(BuildErrorKind::InvalidTarget(t.into()).into());
        }
    }

    let mut me: Option<(PathBuf, state::File, Lock)> =
        if !ps.env().target.as_os_str().is_empty() && !ps.env().unlocked {
            let mut me = PathBuf::from(&ps.env().startdir);
            me.push(&ps.env().pwd);
            me.push(&ps.env().target);
            let myfile = {
                let mut ptx = ProcessTransaction::new(ps, TransactionBehavior::Deferred)
                    .context(BuildErrorKind::Generic)?;
                ptx.set_drop_behavior(DropBehavior::Commit);
                state::File::from_name(&mut ptx, &me.to_string_lossy(), true)
                    .context(BuildErrorKind::Generic)?
            };
            let selflock = ps.new_lock(state::LOG_LOCK_MAGIC + (myfile.id as i32));
            Some((me, myfile, selflock))
        } else {
            None
        };

    let mut result: Result<(), BuildError> = Ok(());
    let mut locked: Vec<(i64, &str)> = Vec::new();
    let mut cheat = || -> Result<i32, Error> {
        let selflock = match &mut me {
            Some((_, _, ref mut selflock)) => selflock,
            None => return Ok(0),
        };
        selflock.try_lock()?;
        if !selflock.is_owned() {
            // redo-log already owns it: let's cheat.
            // Give ourselves one extra token so that the "foreground" log
            // can always make progress.
            Ok(1)
        } else {
            // redo-log isn't watching us (yet)
            selflock.unlock()?;
            Ok(0)
        }
    };
    // In the first cycle, we just build as much as we can without worrying
    // about any lock contention.  If someone else has it locked, we move on.
    {
        let mut seen: HashSet<String> = HashSet::new();
        for t in targets {
            let t = t.as_ref();
            if t.is_empty() {
                result = Err(BuildErrorKind::InvalidTarget(t.into()).into());
                break;
            }
            assert!(ps.is_flushed());
            if seen.contains(t) {
                continue;
            }
            seen.insert(t.into());
            // TODO(maybe): Commit state if !has_token.
            server
                .ensure_token_or_cheat(t, &mut cheat)
                .await
                .context(BuildErrorKind::Generic)?;
            if result.is_err() && !ps.env().keep_going {
                break;
            }
            // TODO(soon): state.check_sane.
            {
                let mut ptx = ProcessTransaction::new(ps, TransactionBehavior::Deferred)
                    .context(BuildErrorKind::Generic)?;
                ptx.set_drop_behavior(DropBehavior::Commit);
                let mut f =
                    state::File::from_name(&mut ptx, t, true).context(BuildErrorKind::Generic)?;
                let mut lock = ptx.state().new_lock(f.id.try_into().unwrap());
                if ptx.state().env().unlocked {
                    lock.force_owned();
                } else {
                    lock.try_lock().context(BuildErrorKind::Generic)?;
                }
                if !lock.is_owned() {
                    // TODO(soon): meta something?
                    locked.push((f.id, t));
                } else {
                    // We had to create f before we had a lock, because we need f.id
                    // to make the lock.  But someone may have updated the state
                    // between then and now.
                    // FIXME: separate obtaining the fid from creating the File.
                    // FIXME: maybe integrate locking into the File object?
                    f.refresh(&mut ptx).context(BuildErrorKind::Generic)?;
                    // TODO(now): Start build job.
                }
            }
            assert!(ps.is_flushed());
        }
    }
    result
}

#[derive(Debug)]
pub(crate) struct BuildError {
    inner: Context<BuildErrorKind>,
}

#[derive(Clone, Eq, PartialEq, Debug, Fail)]
#[non_exhaustive]
pub(crate) enum BuildErrorKind {
    #[fail(display = "Build failed")]
    Generic,
    #[fail(display = "Invalid target {:?}", _0)]
    InvalidTarget(String),
}

impl BuildError {
    #[inline]
    pub(crate) fn kind(&self) -> &BuildErrorKind {
        self.inner.get_context()
    }
}

impl Fail for BuildError {
    fn cause(&self) -> Option<&dyn Fail> {
        self.inner.cause()
    }

    fn backtrace(&self) -> Option<&Backtrace> {
        self.inner.backtrace()
    }
}

impl Display for BuildError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Display::fmt(&self.inner, f)
    }
}

impl From<BuildErrorKind> for BuildError {
    fn from(kind: BuildErrorKind) -> BuildError {
        BuildError {
            inner: Context::new(kind),
        }
    }
}

impl From<Context<BuildErrorKind>> for BuildError {
    fn from(inner: Context<BuildErrorKind>) -> BuildError {
        BuildError { inner: inner }
    }
}

impl Default for BuildErrorKind {
    #[inline]
    fn default() -> BuildErrorKind {
        BuildErrorKind::Generic
    }
}

impl From<&BuildErrorKind> for i32 {
    fn from(kind: &BuildErrorKind) -> i32 {
        match kind {
            BuildErrorKind::InvalidTarget(_) => 204,
            _ => 1,
        }
    }
}
